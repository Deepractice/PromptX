#!/usr/bin/env node

/**
 * GitHub Workflows 解决方案组装脚本
 * 用法: node make.js <solution-name> [target-dir]
 */

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');
const { execSync } = require('child_process');

// 颜色输出
const colors = {
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  reset: '\x1b[0m'
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function error(message) {
  log(`❌ ${message}`, 'red');
  process.exit(1);
}

function success(message) {
  log(`✅ ${message}`, 'green');
}

function info(message) {
  log(`📋 ${message}`, 'yellow');
}

// 解析命令行参数
const args = process.argv.slice(2);
if (args.length < 1) {
  error('请指定解决方案名称\n用法: node make.js <solution-name> [target-dir]');
}

const solutionName = args[0];
const targetDir = args[1] || '.';
const solutionFile = path.join(__dirname, 'solutions', solutionName, 'solution.yml');

// 检查解决方案是否存在
if (!fs.existsSync(solutionFile)) {
  error(`解决方案 '${solutionName}' 不存在`);
}

// 读取解决方案配置
const solutionConfig = yaml.load(fs.readFileSync(solutionFile, 'utf8'));

log(`\n🚀 开始组装解决方案: ${solutionName}`, 'green');
info(solutionConfig.description);

// 配置
const outputPath = path.join(targetDir, solutionConfig.output?.path || '.github');
const mergeWorkflows = solutionConfig.output?.merge_workflows ?? true;

// 创建目标目录
function ensureDir(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

ensureDir(path.join(outputPath, 'workflows'));
ensureDir(path.join(outputPath, 'ISSUE_TEMPLATE'));

// 1. 复制分支策略
function copyBranchStrategy() {
  log('\n1. 配置分支策略', 'green');
  const strategy = solutionConfig.components.branch_strategy;
  const strategyFile = path.join(__dirname, 'branches', 'strategies', `${strategy}.yml`);
  
  if (fs.existsSync(strategyFile)) {
    fs.copyFileSync(strategyFile, path.join(outputPath, 'branch-strategy.yml'));
    success(`已复制分支策略: ${strategy}`);
  } else {
    error(`分支策略 '${strategy}' 不存在`);
  }
}

// 2. 组装命令工作流
function assembleCommands() {
  log('\n2. 组装命令工作流', 'green');
  const commands = solutionConfig.components.commands || [];
  
  if (mergeWorkflows) {
    // TODO: 合并所有命令到一个工作流（需要复杂的 YAML 合并逻辑）
    log('   合并模式暂未实现，使用独立工作流模式', 'yellow');
  }
  
  // 复制每个命令的工作流
  commands.forEach(cmd => {
    const cmdFile = path.join(__dirname, 'commands', cmd, `${cmd}.yml`);
    if (fs.existsSync(cmdFile)) {
      fs.copyFileSync(cmdFile, path.join(outputPath, 'workflows', `${cmd}.yml`));
      success(`复制命令: /${cmd}`);
    } else {
      log(`   ⚠️  命令 '${cmd}' 不存在`, 'yellow');
    }
  });
}

// 2.5 组装事件触发器（新架构：透明的自动化）
function assembleEvents() {
  const events = solutionConfig.components.events || [];
  const flows = solutionConfig.components.flows || []; // 保持向后兼容
  
  // 合并 events 和 flows（向后兼容）
  const allAutomations = [...new Set([...events, ...flows])];
  
  if (allAutomations.length === 0) return;
  
  log('\n2.5 组装自动化触发器', 'green');
  
  allAutomations.forEach(item => {
    // 优先查找 events 目录
    let sourceFile = path.join(__dirname, 'events', item, `${item}.yml`);
    let sourceType = 'event';
    
    // 如果 events 中不存在，尝试 flows 目录（向后兼容）
    if (!fs.existsSync(sourceFile)) {
      sourceFile = path.join(__dirname, 'flows', item, `${item}.yml`);
      sourceType = 'flow';
    }
    
    if (fs.existsSync(sourceFile)) {
      fs.copyFileSync(sourceFile, path.join(outputPath, 'workflows', `${item}.yml`));
      success(`复制${sourceType === 'event' ? '事件' : '流程'}: ${item}`);
    } else {
      log(`   ⚠️  ${item} 不存在于 events 或 flows 目录`, 'yellow');
    }
  });
}

// 3. 生成标签配置
function generateLabels() {
  log('\n3. 生成标签配置', 'green');
  const labels = solutionConfig.components.labels || {};
  const labelsFile = path.join(outputPath, 'labels.yml');
  
  const labelColors = {
    feature: '0e8a16',
    bug: 'd73a4a',
    enhancement: 'a2eeef',
    docs: '0075ca',
    refactor: 'ffd93d',
    critical: 'b60205',
    high: 'd93f0b',
    medium: 'fbca04',
    low: '0e8a16'
  };
  
  let labelsYaml = '# GitHub Issue Labels\n';
  labelsYaml += '# Auto-generated by make.js\n\n';
  
  // 类型标签
  if (labels.types) {
    labelsYaml += '# Type Labels\n';
    labels.types.forEach(label => {
      const colorKey = label.split(':')[1]?.trim() || 'default';
      labelsYaml += `- name: "${label}"\n`;
      labelsYaml += `  color: "${labelColors[colorKey] || 'd876e3'}"\n`;
      labelsYaml += `  description: "${colorKey}"\n\n`;
    });
  }
  
  // 优先级标签
  if (labels.priorities) {
    labelsYaml += '# Priority Labels\n';
    labels.priorities.forEach(label => {
      const colorKey = label.split(':')[1]?.trim() || 'default';
      labelsYaml += `- name: "${label}"\n`;
      labelsYaml += `  color: "${labelColors[colorKey] || 'c5def5'}"\n`;
      labelsYaml += `  description: "${colorKey}"\n\n`;
    });
  }
  
  fs.writeFileSync(labelsFile, labelsYaml);
  success('已生成标签配置');
}

// 4. 复制 Issue 模板
function copyIssueTemplates() {
  log('\n4. 复制 Issue 模板', 'green');
  const templatesDir = path.join(__dirname, 'issues', 'templates');
  
  if (fs.existsSync(templatesDir)) {
    const templates = fs.readdirSync(templatesDir);
    templates.forEach(file => {
      if (file.endsWith('.yml') || file.endsWith('.md')) {
        fs.copyFileSync(
          path.join(templatesDir, file),
          path.join(outputPath, 'ISSUE_TEMPLATE', file)
        );
      }
    });
    success('已复制 Issue 模板');
  }
}

// 5. 生成配置文档
function generateConfigDoc() {
  log('\n5. 生成配置文档', 'green');
  const configDoc = path.join(outputPath, 'WORKFLOW_CONFIG.md');
  
  let doc = `# GitHub Workflow 配置

此配置由 make.js 自动生成，基于解决方案: **${solutionConfig.name}**

## 配置信息

- **解决方案**: ${solutionConfig.name}
- **描述**: ${solutionConfig.description}
- **分支策略**: ${solutionConfig.components.branch_strategy}
- **生成时间**: ${new Date().toISOString()}

## 启用的命令

`;

  (solutionConfig.components.commands || []).forEach(cmd => {
    doc += `- \`/${cmd}\`\n`;
  });
  
  doc += '\n## 自动化事件\n\n';
  
  const events = solutionConfig.components.events || [];
  const flows = solutionConfig.components.flows || [];
  const allAutomations = [...new Set([...events, ...flows])];
  
  if (allAutomations.length > 0) {
    allAutomations.forEach(item => {
      doc += `- \`${item}\`\n`;
    });
  }
  
  doc += '\n## 环境变量\n\n';
  
  if (solutionConfig.environment?.secrets) {
    doc += '需要在 GitHub Settings > Secrets 中配置：\n\n';
    solutionConfig.environment.secrets.forEach(secret => {
      doc += `- **${secret.name}**: ${secret.description}\n`;
    });
  }
  
  fs.writeFileSync(configDoc, doc);
  success('已生成配置文档');
}

// 执行组装
try {
  copyBranchStrategy();
  assembleCommands();
  assembleEvents();  // 更新函数名
  generateLabels();
  copyIssueTemplates();
  generateConfigDoc();
  
  log('\n✅ 解决方案组装完成！', 'green');
  
  console.log(`
下一步操作:
1. 进入项目目录: cd ${targetDir}
2. 查看生成的文件: ls -la ${outputPath}/
3. 提交到 Git: git add ${outputPath} && git commit -m "Add GitHub workflows"
4. 推送到 GitHub: git push

配置 GitHub 仓库:
1. 设置 Secrets: Settings > Secrets and variables > Actions
2. 启用 Actions: Settings > Actions > General
3. 配置分支保护: Settings > Branches
`);

  if (solutionConfig.environment?.secrets) {
    log('\n⚠️  记得配置以下 Secrets:', 'yellow');
    solutionConfig.environment.secrets.forEach(secret => {
      console.log(`   - ${secret.name}`);
    });
  }
} catch (err) {
  error(`组装失败: ${err.message}`);
}