name: Sign Windows Apps with SignPath

on:
  workflow_run:
    workflows: ["Build Desktop Apps"]
    types: [completed]
  workflow_dispatch:  # 允许手动触发
    inputs:
      tag:
        description: 'Release tag to sign (e.g., v1.17.3)'
        required: true
        type: string

jobs:
  sign-windows:
    name: Sign Windows Executable
    runs-on: ubuntu-latest
    # 只在构建成功或手动触发时运行
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    permissions:
      contents: write  # 需要写权限来更新 Release
      id-token: write  # SignPath OIDC 认证需要
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Get release tag
        id: get_tag
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # 手动触发，使用输入的 tag
            echo "tag=${{ github.event.inputs.tag }}" >> $GITHUB_OUTPUT
          else
            # 自动触发，获取最新的 tag
            latest_tag=$(gh release list --limit 1 --json tagName --jq '.[0].tagName')
            echo "tag=$latest_tag" >> $GITHUB_OUTPUT
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Check SignPath credentials
        id: check_credentials
        run: |
          if [[ -z "${{ secrets.SIGNPATH_ORGANIZATION_ID }}" ]] || \
             [[ -z "${{ secrets.SIGNPATH_PROJECT_SLUG }}" ]] || \
             [[ -z "${{ secrets.SIGNPATH_SIGNING_POLICY_SLUG }}" ]]; then
            echo "Missing SignPath credentials, skipping signing"
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "SignPath credentials found"
            echo "skip=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Download Windows installer from Release
        if: steps.check_credentials.outputs.skip != 'true'
        id: download
        run: |
          echo "Downloading Windows installer from release ${{ steps.get_tag.outputs.tag }}..."
          
          # 直接下载到当前目录
          gh release download "${{ steps.get_tag.outputs.tag }}" \
            --pattern "*-win32-*-setup.exe"
          
          # 列出下载的文件
          echo "Downloaded files:"
          ls -la *.exe
          
          # 获取文件名
          exe_file=$(ls *.exe | head -1)
          echo "exe_file=$exe_file" >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Upload installer as artifact for SignPath
        if: steps.check_credentials.outputs.skip != 'true'
        uses: actions/upload-artifact@v4
        id: upload-artifact
        with:
          name: windows-installer-unsigned
          path: "*.exe"
          if-no-files-found: error
      
      - name: Sign with SignPath
        if: steps.check_credentials.outputs.skip != 'true'
        uses: SignPath/github-action-submit-signing-request@v1
        with:
          api-token: ${{ secrets.SIGNPATH_API_TOKEN }}
          organization-id: ${{ secrets.SIGNPATH_ORGANIZATION_ID }}
          project-slug: ${{ secrets.SIGNPATH_PROJECT_SLUG }}
          signing-policy-slug: ${{ secrets.SIGNPATH_SIGNING_POLICY_SLUG }}
          artifact-configuration-slug: ${{ secrets.SIGNPATH_ARTIFACT_CONFIG_SLUG }}
          github-artifact-id: ${{ steps.upload-artifact.outputs.artifact-id }}
          wait-for-completion: true
          output-artifact-directory: signed
      
      - name: Generate latest.yml for signed installer
        if: steps.check_credentials.outputs.skip != 'true'
        id: generate_metadata
        run: |
          if [ -d "signed" ]; then
            cd signed
          fi

          # 获取签名后的文件
          signed_exe=$(ls *.exe | head -1)
          if [ -z "$signed_exe" ]; then
            echo "No signed exe found"
            exit 1
          fi

          echo "Generating latest.yml for $signed_exe..."

          # 计算 SHA512
          sha512_hash=$(sha512sum "$signed_exe" | awk '{print $1}' | xxd -r -p | base64)

          # 获取文件大小
          file_size=$(stat -f%z "$signed_exe" 2>/dev/null || stat -c%s "$signed_exe" 2>/dev/null)

          # 从文件名提取版本号 (格式: promptx-desktop-1.18.0-win32-x64-setup.exe)
          version=$(echo "$signed_exe" | sed -E 's/promptx-desktop-([0-9.]+)-.*/\1/')

          # 获取发布日期
          release_date=$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")

          # 创建 latest.yml
          cat > latest.yml << EOF
version: $version
files:
  - url: $signed_exe
    sha512: $sha512_hash
    size: $file_size
path: $signed_exe
sha512: $sha512_hash
releaseDate: '$release_date'
EOF

          echo "Generated latest.yml:"
          cat latest.yml

          # 保存路径供后续使用
          echo "metadata_path=$(pwd)/latest.yml" >> $GITHUB_OUTPUT

      - name: Upload signed installer back to Release
        if: steps.check_credentials.outputs.skip != 'true'
        run: |
          if [ -d "signed" ]; then
            cd signed
          fi

          # 计数签名的文件
          signed_count=0

          for exe in *.exe; do
            if [ -f "$exe" ]; then
              signed_count=$((signed_count + 1))
              echo "Uploading signed $exe to release..."

              # 使用 --clobber 覆盖现有文件
              gh release upload "${{ steps.get_tag.outputs.tag }}" \
                "$exe" \
                --clobber

              echo "✅ Updated $exe in release"
            fi
          done

          # 上传新生成的 latest.yml
          if [ -f "latest.yml" ]; then
            echo "Uploading updated latest.yml..."
            gh release upload "${{ steps.get_tag.outputs.tag }}" \
              "latest.yml" \
              --clobber
            echo "✅ Updated latest.yml with correct SHA512"
          fi

          echo "Summary: $signed_count files signed and updated"

          # 创建状态文件
          echo "Windows signing completed at $(date)" > signing-status.txt
          echo "Signed: $signed_count files" >> signing-status.txt
          echo "Metadata updated: yes" >> signing-status.txt

          # 上传状态文件
          gh release upload "${{ steps.get_tag.outputs.tag }}" \
            signing-status.txt \
            --clobber
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Post notification comment
        if: steps.check_credentials.outputs.skip != 'true' && github.event_name == 'workflow_run'
        run: |
          # 在对应的 workflow run 上添加评论
          gh run comment ${{ github.event.workflow_run.id }} \
            --body "✅ Windows code signing completed for release ${{ steps.get_tag.outputs.tag }}. Setup file has been signed and updated in the release."
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true  # 评论失败不影响整体流程