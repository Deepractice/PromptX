name: Changeset Command

on:
  issue_comment:
    types: [created]

jobs:
  handle-changeset:
    if: |
      github.event.issue.pull_request &&
      startsWith(github.event.comment.body, '/changeset')
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      pull-requests: write
      issues: write
    
    steps:
      - name: Check permissions
        id: permissions
        uses: actions/github-script@v7
        with:
          script: |
            const username = context.payload.comment.user.login;
            console.log(`Checking permissions for user: ${username}`);
            
            // Allow github-actions bot for automated workflows
            if (username === 'github-actions[bot]' || username === 'github-actions') {
              console.log('Allowing github-actions bot');
              core.setOutput('allowed', true);
              return;
            }
            
            try {
              // Get user's permission level
              const { data: perm } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: username
              });
              
              const hasPermission = ['admin', 'maintain', 'write'].includes(perm.permission);
              core.setOutput('allowed', hasPermission);
              
              if (!hasPermission) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: `‚ùå **Permission denied**\n\n@${username} does not have permission to create changesets. Only contributors with write access can use the \`/changeset\` command.`
                });
                
                await github.rest.reactions.createForIssueComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: context.payload.comment.id,
                  content: '-1'
                });
              }
            } catch (error) {
              core.setOutput('allowed', false);
              console.error('Permission check failed:', error);
            }
      
      - name: Get PR Details
        if: steps.permissions.outputs.allowed == 'true'
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            core.setOutput('branch', pr.data.head.ref);
            core.setOutput('title', pr.data.title);
            core.setOutput('author', pr.data.user.login);
            core.setOutput('number', context.issue.number);
            
            // Add eyes reaction to show command received
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'eyes'
            });
      
      - name: Checkout PR Branch
        if: steps.permissions.outputs.allowed == 'true'
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ steps.pr.outputs.branch }}
          fetch-depth: 0
      
      - name: Configure Git
        if: steps.permissions.outputs.allowed == 'true'
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
      
      - name: Parse Command
        if: steps.permissions.outputs.allowed == 'true'
        id: parse
        shell: bash
        run: |
          COMMAND="${{ github.event.comment.body }}"
          echo "Raw command: $COMMAND"
          
          # Parse: /changeset [--auto|patch|minor|major] [optional message]
          # Default to --auto if no arguments provided
          if [[ "$COMMAND" == "/changeset" ]]; then
            # No arguments = auto mode
            echo "mode=auto" >> $GITHUB_OUTPUT
            echo "valid=true" >> $GITHUB_OUTPUT
            echo "Auto mode: will analyze commits to determine version"
          elif [[ "$COMMAND" =~ ^/changeset[[:space:]]+--auto([[:space:]]+(.*))?$ ]]; then
            # Explicit auto mode
            MESSAGE="${BASH_REMATCH[2]}"
            echo "mode=auto" >> $GITHUB_OUTPUT
            echo "message=$MESSAGE" >> $GITHUB_OUTPUT
            echo "valid=true" >> $GITHUB_OUTPUT
            echo "Auto mode with message: $MESSAGE"
          elif [[ "$COMMAND" =~ ^/changeset[[:space:]]+(patch|minor|major)([[:space:]]+(.*))?$ ]]; then
            # Manual mode with explicit version
            TYPE="${BASH_REMATCH[1]}"
            MESSAGE="${BASH_REMATCH[3]}"
            
            echo "mode=manual" >> $GITHUB_OUTPUT
            echo "type=$TYPE" >> $GITHUB_OUTPUT
            echo "message=$MESSAGE" >> $GITHUB_OUTPUT
            echo "valid=true" >> $GITHUB_OUTPUT
            
            echo "Manual mode: type=$TYPE, message=$MESSAGE"
          else
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "Invalid command format"
          fi
      
      - name: Check and Remove Existing Changeset
        if: steps.permissions.outputs.allowed == 'true' && steps.parse.outputs.valid == 'true'
        id: check
        shell: bash
        run: |
          PR_NUMBER="${{ steps.pr.outputs.number }}"
          
          # Check for existing changeset files in various formats
          FOUND=false
          REMOVED_FILES=""
          
          # Node.js changeset
          for file in .changeset/*-pr-${PR_NUMBER}-*.md .changeset/*pr-${PR_NUMBER}*.md; do
            if [ -f "$file" ]; then
              echo "Found existing Node.js changeset: $file"
              git rm "$file" 2>/dev/null || rm "$file"
              REMOVED_FILES="${REMOVED_FILES} $(basename $file)"
              FOUND=true
            fi
          done
          
          # Python/Go/Generic changes
          for file in .changes/*${PR_NUMBER}*; do
            if [ -f "$file" ]; then
              echo "Found existing changeset: $file"
              git rm "$file" 2>/dev/null || rm "$file"
              REMOVED_FILES="${REMOVED_FILES} $(basename $file)"
              FOUND=true
            fi
          done
          
          if [ "$FOUND" = "true" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "removed_files=$REMOVED_FILES" >> $GITHUB_OUTPUT
            echo "‚úÖ Removed existing changesets: $REMOVED_FILES"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "No existing changeset for PR #${PR_NUMBER}"
          fi
      
      - name: Analyze Version Type (Auto Mode)
        if: steps.permissions.outputs.allowed == 'true' && steps.parse.outputs.mode == 'auto'
        id: analyze
        shell: bash
        run: |
          echo "üîç Analyzing commits to determine version type..."
          
          # Get base branch
          BASE_BRANCH=$(gh pr view ${{ steps.pr.outputs.number }} --json baseRefName -q .baseRefName)
          
          # Analyze commits between base and head
          VERSION_TYPE="patch"
          CHANGES=""
          
          # Get all commits in this PR
          COMMITS=$(git log origin/${BASE_BRANCH}..HEAD --oneline)
          
          while IFS= read -r commit; do
            echo "Analyzing: $commit"
            
            # Check for breaking changes
            if echo "$commit" | grep -qE "(BREAKING CHANGE:|!:)"; then
              VERSION_TYPE="major"
              CHANGES="${CHANGES}\nüí• Breaking: ${commit}"
            # Check for features
            elif echo "$commit" | grep -qE "^[a-f0-9]+ feat(\(.+?\))?:"; then
              if [ "$VERSION_TYPE" != "major" ]; then
                VERSION_TYPE="minor"
              fi
              CHANGES="${CHANGES}\n‚ú® Feature: ${commit}"
            # Check for fixes
            elif echo "$commit" | grep -qE "^[a-f0-9]+ fix(\(.+?\))?:"; then
              CHANGES="${CHANGES}\nüêõ Fix: ${commit}"
            # Check for performance improvements
            elif echo "$commit" | grep -qE "^[a-f0-9]+ perf(\(.+?\))?:"; then
              if [ "$VERSION_TYPE" == "patch" ]; then
                VERSION_TYPE="minor"
              fi
              CHANGES="${CHANGES}\n‚ö° Performance: ${commit}"
            fi
          done <<< "$COMMITS"
          
          # If no conventional commits found, analyze files
          if [ "$VERSION_TYPE" == "patch" ]; then
            FILES_CHANGED=$(git diff origin/${BASE_BRANCH}..HEAD --name-only)
            
            # Check if only docs/tests changed
            ONLY_DOCS_TESTS=true
            while IFS= read -r file; do
              if [[ ! "$file" =~ (README|docs/|test/|\.md$|\.test\.|\.spec\.) ]]; then
                ONLY_DOCS_TESTS=false
                break
              fi
            done <<< "$FILES_CHANGED"
            
            if [ "$ONLY_DOCS_TESTS" == "true" ]; then
              echo "Only documentation or tests changed, using patch"
            fi
          fi
          
          echo "type=$VERSION_TYPE" >> $GITHUB_OUTPUT
          echo "changes=$CHANGES" >> $GITHUB_OUTPUT
          echo "‚úÖ Determined version type: $VERSION_TYPE"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Detect Project Type
        if: steps.permissions.outputs.allowed == 'true' && steps.parse.outputs.valid == 'true'
        id: detect
        shell: bash
        run: |
          # Run detection script
          chmod +x ./commands/changeset/scripts/detect.sh
          PROJECT_TYPE=$(./commands/changeset/scripts/detect.sh)
          echo "project_type=$PROJECT_TYPE" >> $GITHUB_OUTPUT
          echo "Detected project type: $PROJECT_TYPE"
      
      - name: Create Changeset File
        if: |
          steps.permissions.outputs.allowed == 'true' &&
          steps.parse.outputs.valid == 'true'
        shell: bash
        run: |
          # Determine version type based on mode
          if [ "${{ steps.parse.outputs.mode }}" == "auto" ]; then
            TYPE="${{ steps.analyze.outputs.type }}"
            echo "Using auto-detected type: $TYPE"
          else
            TYPE="${{ steps.parse.outputs.type }}"
            echo "Using manually specified type: $TYPE"
          fi
          
          MESSAGE="${{ steps.parse.outputs.message }}"
          PR_TITLE="${{ steps.pr.outputs.title }}"
          PR_NUMBER="${{ steps.pr.outputs.number }}"
          PR_AUTHOR="${{ steps.pr.outputs.author }}"
          PROJECT_TYPE="${{ steps.detect.outputs.project_type }}"
          
          # Use custom message or PR title
          CHANGESET_MESSAGE="${MESSAGE:-$PR_TITLE}"
          
          # Export variables for implementation scripts
          export CHANGESET_TYPE="$TYPE"
          export CHANGESET_MESSAGE="$CHANGESET_MESSAGE"
          export PR_NUMBER="$PR_NUMBER"
          export PR_AUTHOR="$PR_AUTHOR"
          export AUTO_MODE="${{ steps.parse.outputs.mode }}"
          
          # Call appropriate implementation based on project type
          IMPL_SCRIPT="./commands/changeset/scripts/${PROJECT_TYPE}.sh"
          if [ -f "$IMPL_SCRIPT" ]; then
            echo "Using implementation: $IMPL_SCRIPT"
            chmod +x "$IMPL_SCRIPT"
            $IMPL_SCRIPT
          else
            echo "No specific implementation for $PROJECT_TYPE, using generic"
            chmod +x ./commands/changeset/scripts/generic.sh
            ./commands/changeset/scripts/generic.sh
          fi
          
          echo "changeset_created=true" >> $GITHUB_OUTPUT
      
      - name: Commit and Push
        if: |
          steps.permissions.outputs.allowed == 'true' &&
          steps.parse.outputs.valid == 'true'
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Add both .changeset and .changes directories (one will exist based on project type)
          git add .changeset/ 2>/dev/null || true
          git add .changes/ 2>/dev/null || true
          
          # Determine commit message based on whether we're updating or creating
          if [ "${{ steps.check.outputs.exists }}" == "true" ]; then
            COMMIT_MSG="üì¶ Update changeset for PR #${{ steps.pr.outputs.number }}"
          else
            COMMIT_MSG="üì¶ Add changeset for PR #${{ steps.pr.outputs.number }}"
          fi
          
          git commit -m "$COMMIT_MSG"
          git push origin ${{ steps.pr.outputs.branch }}
      
      - name: Post Success Comment
        if: |
          steps.permissions.outputs.allowed == 'true' &&
          steps.parse.outputs.valid == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const mode = '${{ steps.parse.outputs.mode }}';
            const type = mode === 'auto' ? '${{ steps.analyze.outputs.type }}' : '${{ steps.parse.outputs.type }}';
            const existed = '${{ steps.check.outputs.exists }}' === 'true';
            const emoji = {
              'patch': 'ü©π',
              'minor': '‚ú®',
              'major': 'üí•'
            }[type];
            
            const action = existed ? 'Updated' : 'Created';
            let message = `${emoji} **${action} ${type} changeset**\n\n`;
            
            if (existed) {
              const removedFiles = '${{ steps.check.outputs.removed_files }}';
              if (removedFiles) {
                message += `üìù **Replaced previous changeset(s):** ${removedFiles}\n\n`;
              }
            }
            
            if (mode === 'auto') {
              message += `ü§ñ **Auto-detected version type based on commit analysis**\n\n`;
              const changes = `${{ steps.analyze.outputs.changes }}`;
              if (changes) {
                message += `**Detected changes:**\n${changes}\n\n`;
              }
            }
            
            message += `This PR will trigger a ${type} version bump when merged.`;
            
            if (mode === 'auto') {
              message += `\n\nüí° _Tip: You can override this by running \`/changeset [patch|minor|major]\` manually._`;
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: message
            });
            
            // Add rocket reaction for success
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'rocket'
            });
      
      - name: Post Error Comment
        if: steps.permissions.outputs.allowed == 'true' && steps.parse.outputs.valid == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `‚ùå **Invalid command format**\n\nUsage: \`/changeset [--auto|patch|minor|major] [optional message]\`\n\nExamples:\n- \`/changeset\` - Auto-detect version from commits (default)\n- \`/changeset --auto\` - Explicitly use auto mode\n- \`/changeset patch\` - Manual patch version\n- \`/changeset minor Add dark mode support\` - Manual minor with message\n- \`/changeset major Breaking API changes\` - Manual major with message`
            });
            
            // Add confused reaction for error
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'confused'
            });
      
