name: Start Command

on:
  issue_comment:
    types: [created]

jobs:
  # /start development - ÂºÄÂßãÂºÄÂèëÊñ∞ÂäüËÉΩ
  start-development:
    if: |
      github.event.issue.pull_request == null &&
      (startsWith(github.event.comment.body, '/start development') || 
       startsWith(github.event.comment.body, '/start dev'))
    runs-on: ubuntu-latest
    
    permissions:
      issues: write
      contents: write
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
          fetch-depth: 0
          
      - name: Parse command
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const comment = context.payload.comment.body;
            // Support: /start development [#issue] [--from-branch branch]
            const match = comment.match(/\/start (?:development|dev)(?:\s+#?(\d+))?(?:\s+--from-branch\s+(\S+))?/);
            
            if (!match) {
              core.setFailed('Invalid command format');
              return;
            }
            
            // If no issue number provided, use current issue
            const issueNumber = match[1] || context.issue.number;
            const fromBranch = match[2] || '';
            
            core.setOutput('issue_number', issueNumber);
            core.setOutput('from_branch', fromBranch);
            
            console.log(`üìã Issue: #${issueNumber}`);
            console.log(`üìå Base branch: ${fromBranch || 'auto-detect'}`);
            
      - name: Get issue details
        id: issue
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = ${{ steps.parse.outputs.issue_number }};
            const fromBranchParam = '${{ steps.parse.outputs.from_branch }}';
            
            // Get issue details
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(issueNumber)
            });
            
            // Auto-detect base branch if not specified (prefer develop)
            let fromBranch = fromBranchParam;
            if (!fromBranch) {
              const { data: branches } = await github.rest.repos.listBranches({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });
              
              const branchNames = branches.map(b => b.name);
              
              // Priority: develop > dev > main > master
              if (branchNames.includes('develop')) {
                fromBranch = 'develop';
              } else if (branchNames.includes('dev')) {
                fromBranch = 'dev';
              } else if (branchNames.includes('main')) {
                fromBranch = 'main';
              } else if (branchNames.includes('master')) {
                fromBranch = 'master';
              } else {
                const { data: repo } = await github.rest.repos.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo
                });
                fromBranch = repo.default_branch;
              }
              
              console.log(`üîç Auto-detected base branch: ${fromBranch}`);
            }
            
            core.setOutput('from_branch', fromBranch);
            
            // Extract type from labels
            const typeLabel = issue.labels.find(l => l.name.startsWith('type:'));
            const type = typeLabel ? typeLabel.name.split(':')[1].trim() : 'feature';
            
            // Create branch name
            const branchName = `${type}/#${issueNumber}-issue`;
            
            core.setOutput('title', issue.title);
            core.setOutput('number', issueNumber);
            core.setOutput('type', type);
            core.setOutput('branch_name', branchName);
            core.setOutput('assignee', issue.assignee?.login || '');
            
      - name: Create and push branch
        id: branch
        run: |
          BRANCH_NAME="${{ steps.issue.outputs.branch_name }}"
          FROM_BRANCH="${{ steps.issue.outputs.from_branch }}"
          
          # Fetch all branches
          git fetch origin
          
          # Check if branch already exists
          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q .; then
            echo "‚ùå Branch $BRANCH_NAME already exists"
            echo "exists=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Create new branch from base branch
          git checkout -B "$BRANCH_NAME" "origin/$FROM_BRANCH"
          
          # Push the new branch
          git push -u origin "$BRANCH_NAME"
          
          echo "exists=false" >> $GITHUB_OUTPUT
          echo "‚úÖ Created and pushed branch: $BRANCH_NAME"
          
      - name: Update issue and comment
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = ${{ steps.issue.outputs.number }};
            const branchName = '${{ steps.issue.outputs.branch_name }}';
            const fromBranch = '${{ steps.issue.outputs.from_branch }}';
            const branchExists = '${{ steps.branch.outputs.exists }}' === 'true';
            const assignee = '${{ steps.issue.outputs.assignee }}';
            const currentUser = context.payload.comment.user.login;
            
            // Update issue assignee only
            if (!branchExists) {
              const updates = {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(issueNumber)
              };
              
              // Assign to command user if no assignee
              if (!assignee) {
                updates.assignees = [currentUser];
              }
              
              await github.rest.issues.update(updates);
            }
            
            // Post comment with instructions
            const message = branchExists 
              ? `‚ö†Ô∏è **Branch already exists**\n\nThe branch \`${branchName}\` already exists. You can continue working on it.`
              : `üöÄ **Development Started!**
              
              **Branch**: \`${branchName}\`
              **Base**: \`${fromBranch}\`
              **Assigned to**: @${assignee || currentUser}
              
              ### Next Steps:
              \`\`\`bash
              # Pull the latest changes
              git fetch origin
              git checkout ${branchName}
              
              # Start developing...
              # When ready, create a PR to ${fromBranch}
              \`\`\`
              
              ### Workflow:
              1. Develop your feature
              2. Commit changes with conventional commits (feat:, fix:, etc.)
              3. Create PR to \`${fromBranch}\`
              4. Changeset will be auto-generated on PR
              5. After review and merge, changesets accumulate in \`${fromBranch}\`
              `;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: message
            });

  # /start pr - ÂàõÂª∫ Pull Request
  start-pr:
    if: |
      github.event.issue.pull_request == null &&
      startsWith(github.event.comment.body, '/start pr')
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      pull-requests: write
      issues: write
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
          
      - name: Parse command
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const comment = context.payload.comment.body;
            console.log('Parsing command:', comment);
            
            // Extract parameters using regex
            const sourceMatch = comment.match(/--source\s+([^\s]+)/);
            const targetMatch = comment.match(/--target\s+([^\s]+)/);
            const titleMatch = comment.match(/--title\s+"([^"]+)"/);
            const contentMatch = comment.match(/--content\s+"([^"]+)"/);
            const draftMatch = comment.match(/--draft/);
            
            // Set outputs
            core.setOutput('source', sourceMatch ? sourceMatch[1] : '');
            core.setOutput('target', targetMatch ? targetMatch[1] : '');
            core.setOutput('title', titleMatch ? titleMatch[1] : '');
            core.setOutput('content', contentMatch ? contentMatch[1] : '');
            core.setOutput('draft', draftMatch ? 'true' : 'false');
            
            console.log('Parsed parameters:');
            console.log(`  source: ${sourceMatch ? sourceMatch[1] : 'auto-detect'}`);
            console.log(`  target: ${targetMatch ? targetMatch[1] : 'auto-detect'}`);
            console.log(`  title: ${titleMatch ? titleMatch[1] : 'auto-generate'}`);
            console.log(`  content: ${contentMatch ? contentMatch[1] : 'auto-generate'}`);
            console.log(`  draft: ${draftMatch ? 'true' : 'false'}`);
            
      - name: Get issue details
        id: issue
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = context.issue.number;
            
            // Get issue details
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            
            core.setOutput('number', issueNumber);
            core.setOutput('title', issue.title);
            core.setOutput('body', issue.body || '');
            
            // Extract labels
            const labels = issue.labels.map(l => l.name);
            core.setOutput('labels', labels.join(','));
            
            console.log(`Issue #${issueNumber}: ${issue.title}`);
            return issue;
            
      - name: Detect source branch
        id: source
        run: |
          SOURCE="${{ steps.parse.outputs.source }}"
          ISSUE_NUMBER="${{ steps.issue.outputs.number }}"
          
          if [ -n "$SOURCE" ]; then
            echo "Using specified source branch: $SOURCE"
            # Verify branch exists
            if ! git show-ref --verify --quiet "refs/remotes/origin/$SOURCE"; then
              echo "‚ùå Source branch '$SOURCE' does not exist"
              exit 1
            fi
          else
            echo "Auto-detecting source branch for issue #$ISSUE_NUMBER"
            
            # List all remote branches
            git fetch origin
            BRANCHES=$(git branch -r | sed 's/origin\///' | grep -v HEAD)
            
            # Look for branches matching the issue number
            # Match exact pattern: type/#number-issue
            PATTERNS=(
              "feature/#${ISSUE_NUMBER}-issue"
              "fix/#${ISSUE_NUMBER}-issue"
              "docs/#${ISSUE_NUMBER}-issue"
              "chore/#${ISSUE_NUMBER}-issue"
            )
            
            for PATTERN in "${PATTERNS[@]}"; do
              for BRANCH in $BRANCHES; do
                if [[ "$BRANCH" == *"$PATTERN"* ]]; then
                  SOURCE="$BRANCH"
                  echo "Found matching branch: $SOURCE"
                  break 2
                fi
              done
            done
            
            if [ -z "$SOURCE" ]; then
              echo "‚ùå Could not find a branch for issue #$ISSUE_NUMBER"
              echo "Please specify source branch using --source parameter"
              exit 1
            fi
          fi
          
          echo "source=$SOURCE" >> $GITHUB_OUTPUT
          
      - name: Detect target branch
        id: target
        run: |
          TARGET="${{ steps.parse.outputs.target }}"
          SOURCE="${{ steps.source.outputs.source }}"
          
          if [ -n "$TARGET" ]; then
            echo "Using specified target branch: $TARGET"
            # Verify branch exists
            if ! git show-ref --verify --quiet "refs/remotes/origin/$TARGET"; then
              echo "‚ùå Target branch '$TARGET' does not exist"
              exit 1
            fi
          else
            echo "Auto-detecting target branch based on source: $SOURCE"
            
            # Get all branches
            BRANCHES=$(git branch -r | sed 's/origin\///' | sed 's/^[[:space:]]*//' | grep -v HEAD)
            
            # Determine target based on source branch type
            if [[ "$SOURCE" == feature/* ]]; then
              # Features go to develop/dev/main
              for CANDIDATE in develop dev main master; do
                if echo "$BRANCHES" | grep -qx "$CANDIDATE"; then
                  TARGET="$CANDIDATE"
                  echo "Selected target branch: $TARGET"
                  break
                fi
              done
            elif [[ "$SOURCE" == fix/* ]] || [[ "$SOURCE" == hotfix/* ]]; then
              # Fixes go to main/master
              for CANDIDATE in main master; do
                if echo "$BRANCHES" | grep -qx "$CANDIDATE"; then
                  TARGET="$CANDIDATE"
                  echo "Selected target branch: $TARGET"
                  break
                fi
              done
            elif [[ "$SOURCE" == docs/* ]] || [[ "$SOURCE" == chore/* ]]; then
              # Docs and chores go to main/master
              for CANDIDATE in main master; do
                if echo "$BRANCHES" | grep -qx "$CANDIDATE"; then
                  TARGET="$CANDIDATE"
                  echo "Selected target branch: $TARGET"
                  break
                fi
              done
            fi
            
            # Fallback to default branch if not determined
            if [ -z "$TARGET" ]; then
              TARGET=$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@')
              echo "Using default branch: $TARGET"
            fi
          fi
          
          echo "target=$TARGET" >> $GITHUB_OUTPUT
          
      - name: Generate PR content
        id: content
        uses: actions/github-script@v7
        with:
          script: |
            const source = '${{ steps.source.outputs.source }}';
            const target = '${{ steps.target.outputs.target }}';
            const issueNumber = '${{ steps.issue.outputs.number }}';
            const issueTitle = `${{ steps.issue.outputs.title }}`;
            const issueBody = `${{ steps.issue.outputs.body }}`;
            const customTitle = `${{ steps.parse.outputs.title }}`;
            const customContent = `${{ steps.parse.outputs.content }}`;
            
            // Generate PR title
            let prTitle = customTitle;
            if (!prTitle) {
              // Auto-generate from issue title
              const typePrefix = source.split('/')[0];
              const typeMap = {
                'feature': 'feat',
                'fix': 'fix',
                'docs': 'docs',
                'chore': 'chore'
              };
              const prefix = typeMap[typePrefix] || 'feat';
              prTitle = `${prefix}: ${issueTitle}`;
            }
            
            // Generate PR body
            let prBody = customContent;
            if (!prBody) {
              // Auto-generate content
              prBody = `## üìã Summary\n${issueTitle}\n\n`;
              prBody += `## üîó Related Issue\nCloses #${issueNumber}\n\n`;
              
              if (issueBody) {
                // Add issue description summary
                const summary = issueBody.split('\n').slice(0, 5).join('\n');
                prBody += `## üìù Description\n${summary}\n\n`;
              }
              
              // Get commit messages between branches
              prBody += `## ‚úÖ Commits\n`;
              prBody += `View [commit history](https://github.com/${context.repo.owner}/${context.repo.repo}/compare/${target}...${source})\n\n`;
              
              prBody += `## üß™ Checklist\n`;
              prBody += `- [ ] Code has been self-reviewed\n`;
              prBody += `- [ ] Tests pass\n`;
              prBody += `- [ ] Documentation updated (if needed)\n\n`;
              
              prBody += `---\n`;
              prBody += `*This PR was created by the /start pr command*`;
            }
            
            core.setOutput('title', prTitle);
            core.setOutput('body', prBody);
            
            console.log('Generated PR title:', prTitle);
            console.log('Generated PR body:', prBody.substring(0, 200) + '...');
            
      - name: Create pull request
        id: pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const source = '${{ steps.source.outputs.source }}';
            const target = '${{ steps.target.outputs.target }}';
            const title = `${{ steps.content.outputs.title }}`;
            const body = `${{ steps.content.outputs.body }}`;
            const draft = '${{ steps.parse.outputs.draft }}' === 'true';
            const issueNumber = '${{ steps.issue.outputs.number }}';
            const labels = '${{ steps.issue.outputs.labels }}'.split(',').filter(l => l);
            
            try {
              // Check if PR already exists
              const { data: pulls } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${source}`,
                base: target,
                state: 'open'
              });
              
              if (pulls.length > 0) {
                const existingPR = pulls[0];
                console.log(`PR already exists: #${existingPR.number}`);
                core.setOutput('number', existingPR.number);
                core.setOutput('url', existingPR.html_url);
                core.setOutput('exists', 'true');
                core.setOutput('error', 'false');
                return existingPR;
              }
              
              // Create new PR
              const { data: pr } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                head: source,
                base: target,
                draft: draft
              });
              
              console.log(`Created PR #${pr.number}: ${pr.html_url}`);
              
              // Add labels if any
              if (labels.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  labels: labels
                });
              }
              
              core.setOutput('number', pr.number);
              core.setOutput('url', pr.html_url);
              core.setOutput('exists', 'false');
              core.setOutput('error', 'false');
              return pr;
            } catch (error) {
              console.error('Failed to create PR:', error.message);
              core.setOutput('error', 'true');
              core.setOutput('error_message', error.message);
              
              // Post error comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `‚ùå **Failed to Create Pull Request**\n\n**Error**: ${error.message}\n\n**Source**: \`${source}\`\n**Target**: \`${target}\`\n\n### Possible reasons:\n- No commits between the branches\n- Branch doesn't exist\n- Permission issues\n\n### Try:\n1. Make sure you have commits in \`${source}\`\n2. Push your changes: \`git push origin ${source}\`\n3. Run \`/start pr\` again`
              });
              
              throw error;
            }
            
      - name: Comment result
        if: steps.pr.outputs.error != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = '${{ steps.pr.outputs.number }}';
            const prUrl = '${{ steps.pr.outputs.url }}';
            const exists = '${{ steps.pr.outputs.exists }}' === 'true';
            const source = '${{ steps.source.outputs.source }}';
            const target = '${{ steps.target.outputs.target }}';
            const draft = '${{ steps.parse.outputs.draft }}' === 'true';
            
            let message;
            if (exists) {
              message = `‚ö†Ô∏è **Pull Request Already Exists**\n\n`;
              message += `PR #${prNumber} is already open for this branch.\n\n`;
              message += `**View PR**: ${prUrl}`;
            } else {
              message = `‚úÖ **Pull Request Created!**\n\n`;
              message += `**PR**: #${prNumber}\n`;
              message += `**Source**: \`${source}\`\n`;
              message += `**Target**: \`${target}\`\n`;
              message += `**Status**: ${draft ? 'üìù Draft' : '‚úÖ Ready for review'}\n\n`;
              message += `**View PR**: ${prUrl}\n\n`;
              message += `### Next Steps:\n`;
              if (draft) {
                message += `1. Complete your changes\n`;
                message += `2. Mark PR as ready for review\n`;
                message += `3. Request reviewers\n`;
              } else {
                message += `1. Wait for CI checks to pass\n`;
                message += `2. Request reviews\n`;
                message += `3. Address feedback\n`;
                message += `4. Merge when approved\n`;
              }
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: message
            });

  # /start release - ÂºÄÂßãÂèëÂ∏ÉÊµÅÁ®ã
  start-release:
    if: |
      github.event.issue.pull_request == null &&
      startsWith(github.event.comment.body, '/start release')
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      issues: write
      pull-requests: write
      
    steps:
      - name: Parse command
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const command = context.payload.comment.body.trim();
            // Parse: /start release [version] [--preview]
            const match = command.match(/^\/start release(?:\s+([\d.]+(?:-\w+)?))?(?:\s+(--preview))?$/);
            
            if (!match) {
              core.setFailed('Invalid command format');
              return;
            }
            
            const version = match[1];
            const isPreview = match[2] === '--preview';
            core.setOutput('version', version || '');
            core.setOutput('preview', isPreview);
            console.log(`üì¶ Version: ${version || 'auto-detect'}`);
            console.log(`üëÅÔ∏è Preview mode: ${isPreview}`);
            
      - name: Checkout develop
        uses: actions/checkout@v4
        with:
          ref: develop
          fetch-depth: 0
          token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Install dependencies
        run: |
          # Install changesets CLI
          npm install -g @changesets/cli
          
          # Install project dependencies
          if [ -f "pnpm-lock.yaml" ]; then
            npm install -g pnpm
            pnpm install
          elif [ -f "yarn.lock" ]; then
            npm install -g yarn
            yarn install
          else
            npm install
          fi
          
      - name: Check changesets
        id: check
        run: |
          # Count available changesets
          CHANGESET_COUNT=$(ls -1 .changeset/*.md 2>/dev/null | grep -v README.md | wc -l)
          echo "changeset_count=$CHANGESET_COUNT" >> $GITHUB_OUTPUT
          
          if [ "$CHANGESET_COUNT" -eq 0 ]; then
            echo "‚ùå No changesets found in develop branch"
            echo "has_changesets=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "has_changesets=true" >> $GITHUB_OUTPUT
          echo "üì¶ Found $CHANGESET_COUNT changesets to consume"
          
          # List changesets for reference
          echo "Changesets to be consumed:"
          ls -1 .changeset/*.md | grep -v README.md
          
      - name: Determine version
        if: steps.check.outputs.has_changesets == 'true'
        id: version
        run: |
          if [ -n "${{ steps.parse.outputs.version }}" ]; then
            VERSION="${{ steps.parse.outputs.version }}"
          else
            # Get current version from package.json
            CURRENT_VERSION=$(node -p "require('./package.json').version")
            echo "üìä Current version: $CURRENT_VERSION"
            
            # Temporarily run changeset version to calculate next version
            # We'll do this in a way that doesn't modify files
            cp package.json package.json.bak
            
            # Run changeset version to get the actual next version
            npx changeset version 2>/dev/null || true
            
            # Get the new version that changeset calculated
            NEXT_VERSION=$(node -p "require('./package.json').version")
            echo "üìà Next version calculated by changeset: $NEXT_VERSION"
            
            # Restore original package.json
            mv package.json.bak package.json
            
            # Clean up any other files changeset might have modified
            git checkout -- .changeset/ 2>/dev/null || true
            
            VERSION="$NEXT_VERSION"
          fi
          
          # For release branches, we use the clean version (no prerelease suffix)
          # The actual release will be beta, but branch name should be clean
          BASE_VERSION=$(echo "$VERSION" | sed 's/-.*$//')
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "base_version=$BASE_VERSION" >> $GITHUB_OUTPUT
          echo "üìå Release version: $VERSION"
          echo "üåø Branch version: $BASE_VERSION"
          
      - name: Preview changesets (dry run)
        if: steps.check.outputs.has_changesets == 'true' && steps.parse.outputs.preview == 'true'
        id: preview
        run: |
          echo "üîç Analyzing changesets (preview mode)..."
          
          # Count changesets by type
          MAJOR_COUNT=0
          MINOR_COUNT=0
          PATCH_COUNT=0
          
          for file in .changeset/*.md; do
            [ -f "$file" ] || continue
            [ "$file" = ".changeset/README.md" ] && continue
            
            # Parse the changeset file to determine version type
            # Look for the version type in the YAML frontmatter
            if grep -q '": major' "$file"; then
              MAJOR_COUNT=$((MAJOR_COUNT + 1))
            elif grep -q '": minor' "$file"; then
              MINOR_COUNT=$((MINOR_COUNT + 1))
            elif grep -q '": patch' "$file"; then
              PATCH_COUNT=$((PATCH_COUNT + 1))
            fi
          done
          
          # Determine next version type
          if [ $MAJOR_COUNT -gt 0 ]; then
            VERSION_TYPE="major"
          elif [ $MINOR_COUNT -gt 0 ]; then
            VERSION_TYPE="minor"
          else
            VERSION_TYPE="patch"
          fi
          
          echo "major_count=$MAJOR_COUNT" >> $GITHUB_OUTPUT
          echo "minor_count=$MINOR_COUNT" >> $GITHUB_OUTPUT
          echo "patch_count=$PATCH_COUNT" >> $GITHUB_OUTPUT
          echo "version_type=$VERSION_TYPE" >> $GITHUB_OUTPUT
          
      - name: Consume changesets on develop
        if: steps.check.outputs.has_changesets == 'true' && steps.parse.outputs.preview != 'true'
        id: consume
        run: |
          echo "üîÑ Consuming changesets on develop branch..."
          
          # Ensure we're on develop branch
          git checkout develop
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Run changeset version to consume changesets
          npx changeset version
          
          # Get the new version after consuming changesets
          NEW_VERSION=$(node -p "require('./package.json').version")
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          
          # Commit version bump on develop
          git add .
          git commit -m "chore: release version $NEW_VERSION

          Consumed ${{ steps.check.outputs.changeset_count }} changesets from develop branch" || echo "No changes to commit"
          
          # Push the updated develop branch
          git push origin develop
          
          echo "‚úÖ Consumed changesets and updated version to $NEW_VERSION on develop"
          
      - name: Create release branch from updated develop
        if: steps.check.outputs.has_changesets == 'true' && steps.parse.outputs.preview != 'true'
        id: branch
        run: |
          # Use the actual new version for branch name
          NEW_VERSION="${{ steps.consume.outputs.new_version }}"
          BASE_VERSION=$(echo "$NEW_VERSION" | sed 's/-.*$//')
          BRANCH_NAME="release/${BASE_VERSION}"
          
          echo "üìå Creating release branch: $BRANCH_NAME from updated develop"
          
          # Check if branch already exists
          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q .; then
            echo "‚ùå Release branch $BRANCH_NAME already exists"
            echo "exists=true" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Create release branch from current (updated) develop
          git checkout -b "$BRANCH_NAME"
          
          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "exists=false" >> $GITHUB_OUTPUT
          echo "‚úÖ Created branch: $BRANCH_NAME with version $NEW_VERSION"
          
      - name: Push release branch
        if: steps.check.outputs.has_changesets == 'true' && steps.branch.outputs.exists != 'true' && steps.parse.outputs.preview != 'true'
        run: |
          git push -u origin "${{ steps.branch.outputs.branch }}"
          
      - name: Clean develop branch
        if: steps.check.outputs.has_changesets == 'true' && steps.branch.outputs.exists != 'true' && steps.parse.outputs.preview != 'true'
        run: |
          # Switch back to develop
          git checkout develop
          
          # Remove consumed changesets
          rm -f .changeset/*.md
          echo "# Changesets consumed by ${{ steps.branch.outputs.branch }}" > .changeset/.consumed
          
          # Commit the cleanup
          git add .changeset/
          git commit -m "chore: clear changesets consumed by ${{ steps.branch.outputs.branch }}" || echo "No changesets to clear"
          git push origin develop
          
      - name: Create PR
        if: steps.check.outputs.has_changesets == 'true' && steps.branch.outputs.exists != 'true' && steps.parse.outputs.preview != 'true'
        id: pr
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          BRANCH="${{ steps.branch.outputs.branch }}"
          VERSION="${{ steps.consume.outputs.new_version }}"
          
          # Try to create PR from release to main
          set +e
          PR_OUTPUT=$(gh pr create \
            --base main \
            --head "$BRANCH" \
            --title "üöÄ Release $VERSION" \
            --body "## Release $VERSION
            
            ### Changesets Consumed
            - **Count**: ${{ steps.check.outputs.changeset_count }} changesets
            - **Source**: develop branch
            - **Version**: $VERSION
            
            ### Release Checklist
            - [ ] Run tests: \`/test\`
            - [ ] Create beta release: \`/release --prerelease beta\`
            - [ ] Publish beta: \`/publish npm --tag next\`
            - [ ] Test beta version
            - [ ] Create RC if needed: \`/release --prerelease rc\`
            - [ ] Final review
            - [ ] Approve and merge PR
            - [ ] Create final release: \`/release\`
            - [ ] Publish to npm: \`/publish\`
            
            ### Notes
            This release branch was created from develop with accumulated changesets.
            All changesets have been consumed and cleared from develop.
            " 2>&1)
          PR_EXIT_CODE=$?
          set -e
          
          if [ $PR_EXIT_CODE -eq 0 ]; then
            echo "pr_url=$PR_OUTPUT" >> $GITHUB_OUTPUT
            echo "pr_created=true" >> $GITHUB_OUTPUT
            echo "‚úÖ PR created successfully: $PR_OUTPUT"
          else
            echo "pr_created=false" >> $GITHUB_OUTPUT
            echo "pr_error=$PR_OUTPUT" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Failed to create PR automatically: $PR_OUTPUT"
            echo "‚ö†Ô∏è You may need to create the PR manually or configure PAT_TOKEN secret"
          fi
          
      - name: Comment result
        uses: actions/github-script@v7
        with:
          script: |
            const hasChangesets = '${{ steps.check.outputs.has_changesets }}' === 'true';
            const branchExists = '${{ steps.branch.outputs.exists }}' === 'true';
            const isPreview = '${{ steps.parse.outputs.preview }}' === 'true';
            
            if (!hasChangesets) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `‚ùå **No changesets to release**
                
                There are no changesets in the develop branch to consume.
                Please ensure features have been merged with changesets before starting a release.`
              });
              return;
            }
            
            // Preview mode response
            if (isPreview) {
              const version = '${{ steps.version.outputs.version }}';
              const changesetCount = '${{ steps.check.outputs.changeset_count }}';
              const majorCount = '${{ steps.preview.outputs.major_count }}' || '0';
              const minorCount = '${{ steps.preview.outputs.minor_count }}' || '0';
              const patchCount = '${{ steps.preview.outputs.patch_count }}' || '0';
              const versionType = '${{ steps.preview.outputs.version_type }}';
              
              let emoji = 'ü©π';
              if (versionType === 'major') emoji = 'üí•';
              else if (versionType === 'minor') emoji = '‚ú®';
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `### üëÅÔ∏è Release Preview
                
                **Next version**: \`${version}\` (${emoji} ${versionType})
                **Total changesets**: ${changesetCount}
                
                ### Breakdown:
                - üí• Major: ${majorCount}
                - ‚ú® Minor: ${minorCount}
                - ü©π Patch: ${patchCount}
                
                ### Ready to release?
                Run \`/start release\` to:
                1. Create release branch \`release/${version.split('-')[0]}\`
                2. Consume all changesets
                3. Create PR to main
                4. Begin release process
                
                ### Not ready yet?
                Continue developing on \`develop\` branch.
                New changesets will be included in the next release.`
              });
              return;
            }
            
            if (branchExists) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `‚ùå **Release branch already exists**
                
                The release branch already exists. Please complete the current release before starting a new one.`
              });
              return;
            }
            
            const branch = '${{ steps.branch.outputs.branch }}';
            const version = '${{ steps.consume.outputs.new_version }}';
            const prUrl = '${{ steps.pr.outputs.pr_url }}';
            const changesetCount = '${{ steps.check.outputs.changeset_count }}';
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `### üéâ Release Started!
              
              **Branch**: \`${branch}\`
              **Version**: \`${version}\`
              **Changesets**: ${changesetCount} consumed from develop
              **PR**: ${prUrl}
              
              ### Next Steps:
              1. Switch to release branch: \`git checkout ${branch}\`
              2. Run tests: \`/test\`
              3. Create beta release: \`/release --prerelease beta\`
              4. Publish beta: \`/publish npm --tag next\`
              5. Test the beta version
              6. When ready, merge PR to main
              7. After merge, run \`/release\` on main
              8. Finally, \`/publish\` to npm
              
              ### Important:
              - Changesets have been consumed and cleared from develop
              - New features can continue to be developed on develop
              - This release branch is independent and won't affect ongoing development
              `
            });