name: Release Created Event

on:
  release:
    types: [created, published]

jobs:
  auto-deploy:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
      contents: read
      deployments: write
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Use the tag directly, not as a branch name
          ref: refs/tags/${{ github.event.release.tag_name }}
          fetch-depth: 0
          
      - name: Detect project type
        id: detect
        run: |
          # Check what type of project this is
          TARGET=""
          
          if [ -f "package.json" ]; then
            # Check if it's a library that should be published to NPM
            if grep -q '"main"\|"module"\|"exports"' package.json; then
              TARGET="npm"
              echo "🔍 Detected NPM package"
            elif [ -f "Dockerfile" ]; then
              TARGET="docker"
              echo "🔍 Detected Node.js app with Docker"
            else
              TARGET="npm"
              echo "🔍 Detected Node.js project (defaulting to NPM)"
            fi
          elif [ -f "Dockerfile" ]; then
            TARGET="docker"
            echo "🔍 Detected Docker project"
          else
            echo "⚠️ No deployable target detected"
            TARGET="none"
          fi
          
          echo "target=$TARGET" >> $GITHUB_OUTPUT
          
      - name: Determine deployment tag
        id: tag
        run: |
          # Check if this is a prerelease or regular release
          IS_PRERELEASE="${{ github.event.release.prerelease }}"
          RELEASE_TAG="${{ github.event.release.tag_name }}"
          
          if [ "$IS_PRERELEASE" = "true" ]; then
            DEPLOY_TAG="beta"
            echo "🏷️ Prerelease detected, will deploy with 'beta' tag"
          else
            DEPLOY_TAG="latest"
            echo "🏷️ Regular release detected, will deploy with 'latest' tag"
          fi
          
          echo "deploy_tag=$DEPLOY_TAG" >> $GITHUB_OUTPUT
          echo "release_tag=$RELEASE_TAG" >> $GITHUB_OUTPUT
          
      - name: Find related issue
        id: issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const releaseTag = '${{ github.event.release.tag_name }}';
            const releaseBody = context.payload.release.body || '';
            
            // Try to extract issue number from release body
            // Look for patterns like "Closes #123" or "Fixes #123" or just "#123"
            const issueMatch = releaseBody.match(/#(\d+)/);
            
            if (issueMatch) {
              const issueNumber = issueMatch[1];
              console.log(`Found related issue: #${issueNumber}`);
              core.setOutput('issue_number', issueNumber);
              core.setOutput('has_issue', 'true');
            } else {
              // Try to find the most recent release PR
              const { data: prs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed',
                base: 'main',
                sort: 'updated',
                direction: 'desc',
                per_page: 10
              });
              
              // Find a PR that mentions this release version
              const releasePR = prs.find(pr => 
                pr.title.includes(releaseTag) || 
                pr.body?.includes(releaseTag) ||
                pr.title.includes('release') || 
                pr.title.includes('Release')
              );
              
              if (releasePR) {
                console.log(`Found related PR: #${releasePR.number}`);
                core.setOutput('issue_number', releasePR.number);
                core.setOutput('has_issue', 'true');
              } else {
                console.log('No related issue or PR found');
                core.setOutput('has_issue', 'false');
              }
            }
            
      - name: Post deployment notification
        if: steps.detect.outputs.target != 'none'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const target = '${{ steps.detect.outputs.target }}';
            const deployTag = '${{ steps.tag.outputs.deploy_tag }}';
            const releaseTag = '${{ steps.tag.outputs.release_tag }}';
            const releaseUrl = context.payload.release.html_url;
            
            let message = `## 🚀 Auto-Deployment Triggered\n\n`;
            message += `**Release**: [${releaseTag}](${releaseUrl})\n`;
            message += `**Target**: ${target}\n`;
            message += `**Tag**: ${deployTag}\n\n`;
            message += `Deployment will start automatically...`;
            
            // Post to issue/PR if found, otherwise create a deployment issue
            const hasIssue = '${{ steps.issue.outputs.has_issue }}' === 'true';
            let commentTarget;
            
            if (hasIssue) {
              commentTarget = parseInt('${{ steps.issue.outputs.issue_number }}');
            } else {
              // Create a deployment tracking issue
              const { data: issue } = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `🚀 Deployment: ${releaseTag}`,
                body: message,
                labels: ['deployment', 'automated']
              });
              commentTarget = issue.number;
              console.log(`Created deployment tracking issue #${issue.number}`);
            }
            
            // Post notification
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: commentTarget,
              body: message
            });
            
            core.setOutput('comment_target', commentTarget);
            
      - name: Trigger deployment
        if: steps.detect.outputs.target != 'none'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const target = '${{ steps.detect.outputs.target }}';
            const deployTag = '${{ steps.tag.outputs.deploy_tag }}';
            const commentTarget = parseInt('${{ steps.issue.outputs.comment_target }}') || 
                                 parseInt('${{ steps.issue.outputs.issue_number }}');
            
            // Wait a moment for the notification to be posted
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // Trigger the deployment command with version from tag
            const releaseTag = '${{ steps.tag.outputs.release_tag }}';
            const version = releaseTag.replace('v', ''); // Remove 'v' prefix if present
            const deployCommand = `/deploy ${target} --tag ${deployTag} --version ${version} --auto`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: commentTarget,
              body: deployCommand
            });
            
            console.log(`✅ Triggered deployment: ${deployCommand}`);
            
      - name: Skip deployment notification
        if: steps.detect.outputs.target == 'none'
        uses: actions/github-script@v7
        with:
          script: |
            console.log('⚠️ No deployable target detected, skipping deployment');
            
            // Only notify if there's a related issue
            const hasIssue = '${{ steps.issue.outputs.has_issue }}' === 'true';
            if (hasIssue) {
              const issueNumber = parseInt('${{ steps.issue.outputs.issue_number }}');
              const releaseTag = '${{ steps.tag.outputs.release_tag }}';
              const releaseUrl = context.payload.release.html_url;
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: `ℹ️ Release [${releaseTag}](${releaseUrl}) created.\n\nNo automatic deployment configured for this project type.`
              });
            }
  
  # Build and upload Desktop applications after release is created
  desktop-build:
    needs: auto-deploy
    if: always() # Run even if auto-deploy skips
    strategy:
      matrix:
        include:
          - os: macos-latest
            platform: mac
            artifacts: "release/*.dmg release/*.zip release/latest-mac.yml"
          - os: windows-latest
            platform: win
            artifacts: "release/*.exe release/*.msi release/latest.yml"
          - os: ubuntu-latest
            platform: linux
            artifacts: "release/*.AppImage release/*.deb release/*.rpm release/*.snap release/latest-linux.yml"
    
    runs-on: ${{ matrix.os }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: refs/tags/${{ github.event.release.tag_name }}
          fetch-depth: 0
      
      - name: Check for Desktop app
        id: check
        run: |
          # Check if this repository has a desktop app
          if [ -d "apps/desktop" ]; then
            echo "has_desktop=true" >> $GITHUB_OUTPUT
            echo "✅ Desktop app found, will build for ${{ matrix.platform }}"
          else
            echo "has_desktop=false" >> $GITHUB_OUTPUT
            echo "No desktop app found, skipping build"
          fi
      
      - name: Setup Node.js
        if: steps.check.outputs.has_desktop == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install pnpm
        if: steps.check.outputs.has_desktop == 'true'
        uses: pnpm/action-setup@v2
        with:
          version: 8
          run_install: false
      
      - name: Get pnpm store directory
        if: steps.check.outputs.has_desktop == 'true'
        id: pnpm-cache
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT
      
      - name: Setup pnpm cache
        if: steps.check.outputs.has_desktop == 'true'
        uses: actions/cache@v3
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
      
      - name: Install dependencies
        if: steps.check.outputs.has_desktop == 'true'
        run: |
          pnpm install --frozen-lockfile || pnpm install
      
      - name: Build Desktop Application
        if: steps.check.outputs.has_desktop == 'true'
        run: |
          cd apps/desktop
          
          # Extract version from release tag
          RELEASE_TAG="${{ github.event.release.tag_name }}"
          VERSION="${RELEASE_TAG#v}"  # Remove 'v' prefix
          
          # Update version to match release
          node -e "const pkg=require('./package.json'); pkg.version='$VERSION'; require('fs').writeFileSync('./package.json', JSON.stringify(pkg, null, 2))"
          
          # Install desktop dependencies
          pnpm install --frozen-lockfile || pnpm install
          
          # Build
          pnpm run build
          
          # Package for current platform
          pnpm run package:${{ matrix.platform }}
          
          # List artifacts
          echo "📦 Built artifacts for ${{ matrix.platform }}:"
          ls -la release/
      
      - name: Upload artifacts to Release
        if: steps.check.outputs.has_desktop == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          cd apps/desktop
          
          # Upload all artifacts for this platform
          for pattern in ${{ matrix.artifacts }}; do
            for file in $pattern; do
              if [ -f "$file" ]; then
                echo "Uploading $file..."
                gh release upload "${{ github.event.release.tag_name }}" "$file" --clobber
              fi
            done
          done
          
          echo "✅ Uploaded ${{ matrix.platform }} artifacts to release ${{ github.event.release.tag_name }}"