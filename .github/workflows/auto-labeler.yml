name: Auto Labeler

on:
  pull_request:
    types: [opened, reopened]
    branches: [develop, test, staging, main]

jobs:
  auto-label:
    name: Auto Label PR
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      issues: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Analyze branch and apply labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const sourceBranch = pr.head.ref;
            const targetBranch = pr.base.ref;
            const prTitle = pr.title;
            
            console.log(`üîç Analyzing PR: ${sourceBranch} ‚Üí ${targetBranch}`);
            console.log(`üìù PR Title: ${prTitle}`);
            
            // First try to parse PR title for conventional commit format
            const titlePattern = /^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\(.+\))?(!)?:\s*(.+)/;
            const titleMatch = prTitle.match(titlePattern);
            
            // Parse branch name as fallback
            const branchPattern = /^(\w+)\/#?\d+-[\w-]+$/;
            const branchMatch = sourceBranch.match(branchPattern);
            
            // Determine the type from PR title or branch name
            let detectedType;
            let isBreakingChange = false;
            
            if (titleMatch) {
              detectedType = titleMatch[1];
              isBreakingChange = titleMatch[3] === '!';
              console.log(`‚úÖ Detected type from PR title: ${detectedType}${isBreakingChange ? ' (BREAKING)' : ''}`);
            } else if (branchMatch) {
              detectedType = branchMatch[1];
              console.log(`üîç Detected type from branch: ${detectedType}`);
            } else {
              console.log('‚ö†Ô∏è Could not determine type from PR title or branch name');
              return;
            }
            
            // Label rules based on detected type
            // Priority: PR title > branch name
            const typeRules = {
              'feat': {
                labels: [isBreakingChange ? 'changeset/major' : 'changeset/minor', 'merge/squash'],
                publish: true
              },
              'feature': {  // Support branch naming
                labels: ['changeset/minor', 'merge/squash'],
                publish: true
              },
              'fix': {
                labels: ['changeset/patch', 'merge/squash'],
                publish: true
              },
              'docs': {
                labels: ['changeset/none', 'merge/squash'],
                publish: false
              },
              'doc': {  // Support branch naming
                labels: ['changeset/none', 'merge/squash'],
                publish: false
              },
              'style': {
                labels: ['changeset/none', 'merge/squash'],
                publish: false
              },
              'refactor': {
                labels: ['changeset/patch', 'merge/squash'],
                publish: true
              },
              'perf': {
                labels: ['changeset/patch', 'merge/squash'],
                publish: true
              },
              'test': {
                labels: ['changeset/none', 'merge/squash'],
                publish: false
              },
              'build': {
                labels: ['changeset/patch', 'merge/squash'],
                publish: true
              },
              'ci': {
                labels: ['changeset/none', 'merge/squash'],
                publish: false
              },
              'chore': {
                labels: ['changeset/none', 'merge/squash'],
                publish: false
              },
              'revert': {
                labels: ['changeset/patch', 'merge/squash'],
                publish: true
              }
            };
            
            // Find matching rule
            const matchedRule = typeRules[detectedType];
            
            if (!matchedRule) {
              console.log(`‚ö†Ô∏è No rule defined for type: ${detectedType}`);
              // Default to no version change for unknown types
              const defaultRule = {
                labels: ['changeset/none', 'merge/squash'],
                publish: false
              };
              matchedRule = defaultRule;
            }
            
            console.log(`‚úÖ Matched rule for type: ${detectedType}`);
            
            // Get existing labels
            const { data: existingLabels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number
            });
            
            const existingLabelNames = existingLabels.map(l => l.name);
            console.log('üìå Existing labels:', existingLabelNames);
            
            // Check for conflicting changeset labels
            const hasChangesetLabel = existingLabelNames.some(l => l.startsWith('changeset/'));
            const hasTypeLabel = existingLabelNames.some(l => l.startsWith('type:'));
            const hasMergeLabel = existingLabelNames.some(l => l.startsWith('merge/'));
            
            // Prepare labels to add
            let labelsToAdd = [...matchedRule.labels];
            
            // Add publish label based on target branch and changeset type
            if (matchedRule.publish) {
              const publishLabel = {
                'develop': 'publish/dev',
                'test': 'publish/alpha',
                'staging': 'publish/beta',
                'main': 'publish/latest'
              }[targetBranch];
              
              if (publishLabel) {
                labelsToAdd.push(publishLabel);
              }
            }
            
            // Filter out labels that would conflict
            if (hasChangesetLabel) {
              labelsToAdd = labelsToAdd.filter(l => !l.startsWith('changeset/'));
              console.log('‚ö†Ô∏è Skipping changeset label - already exists');
            }
            if (hasTypeLabel) {
              labelsToAdd = labelsToAdd.filter(l => !l.startsWith('type:'));
              console.log('‚ö†Ô∏è Skipping type label - already exists');
            }
            if (hasMergeLabel) {
              labelsToAdd = labelsToAdd.filter(l => !l.startsWith('merge/'));
              console.log('‚ö†Ô∏è Skipping merge label - already exists');
            }
            
            // Filter out already existing labels
            labelsToAdd = labelsToAdd.filter(l => !existingLabelNames.includes(l));
            
            if (labelsToAdd.length === 0) {
              console.log('‚ÑπÔ∏è No new labels to add');
              return;
            }
            
            console.log('üè∑Ô∏è Adding labels:', labelsToAdd);
            
            // Add the labels
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              labels: labelsToAdd
            });
            
            // Add a comment explaining the auto-labeling
            let commentBody = 'ü§ñ **Auto-labeler applied the following labels:**\n\n';
            commentBody += labelsToAdd.map(l => '- `' + l + '`').join('\n');
            commentBody += '\n\n**Based on:**\n';
            commentBody += `- Source branch: \`${sourceBranch}\`\n`;
            commentBody += `- Target branch: \`${targetBranch}\`\n\n`;
            
            if (matchedRule.publish) {
              commentBody += 'üì¶ This PR will be automatically published after merge.\n\n';
            } else {
              commentBody += '‚è∏Ô∏è This PR will not trigger automatic publishing (changeset/none).\n\n';
            }
            
            commentBody += 'You can manually adjust these labels if needed.';
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body: commentBody
            });
            
            console.log('‚úÖ Auto-labeling complete!');